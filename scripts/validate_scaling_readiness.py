#!/usr/bin/env python3\n\"\"\"\nSystem-Wide Scaling Validation Script\n\nThis script validates that the coordinator can scale from simple to complex\nworkflows without architectural changes. Each step builds on the previous\nwith incremental complexity validation.\n\nUsage:\n    python scripts/validate_scaling_readiness.py --from step1 --to step2\n    python scripts/validate_scaling_readiness.py --from step2 --to step3\n    python scripts/validate_scaling_readiness.py --complete-integration\n\"\"\"\n\nimport sys\nimport argparse\nimport time\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Tuple\nimport logging\n\n# Add project root to path\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))\n\nfrom src.core.logging import ComponentLogger\nfrom src.core.events.enhanced_isolation import get_enhanced_isolation_manager, IsolationTestSuite\n\n\nclass SystemScalingValidator:\n    \"\"\"Validates that coordinator can scale complexity without architectural changes.\"\"\"\n    \n    def __init__(self):\n        self.logger = ComponentLogger(\"scaling_validator\", \"system_integration\")\n        self.isolation_manager = get_enhanced_isolation_manager()\n        self.scaling_results = {}\n    \n    def validate_step_transition(self, from_step: str, to_step: str) -> Dict[str, Any]:\n        \"\"\"Validate scaling from one step to the next.\"\"\"\n        \n        print(f\"\ud83d\ude80 Validating scaling transition: {from_step} \u2192 {to_step}\")\n        print(\"=\" * 60)\n        \n        # 1. Validate previous step still works\n        from_step_results = self._validate_step_functionality(from_step)\n        if not from_step_results['success']:\n            return {\n                'success': False,\n                'error': f\"Base step {from_step} validation failed\",\n                'from_step': from_step,\n                'to_step': to_step\n            }\n        \n        # 2. Validate new step works\n        to_step_results = self._validate_step_functionality(to_step)\n        if not to_step_results['success']:\n            return {\n                'success': False,\n                'error': f\"Target step {to_step} validation failed\",\n                'from_step': from_step,\n                'to_step': to_step\n            }\n        \n        # 3. Validate coordinator scaling\n        coordinator_scaling = self._validate_coordinator_scaling(from_step, to_step)\n        \n        # 4. Validate event isolation still works\n        isolation_results = self._validate_isolation_scaling(from_step, to_step)\n        \n        # 5. Validate performance scaling\n        performance_results = self._validate_performance_scaling(from_step, to_step)\n        \n        # 6. Compile results\n        scaling_validation = {\n            'success': all([\n                from_step_results['success'],\n                to_step_results['success'],\n                coordinator_scaling['success'],\n                isolation_results['success'],\n                performance_results['success']\n            ]),\n            'from_step': from_step,\n            'to_step': to_step,\n            'from_step_validation': from_step_results,\n            'to_step_validation': to_step_results,\n            'coordinator_scaling': coordinator_scaling,\n            'isolation_scaling': isolation_results,\n            'performance_scaling': performance_results,\n            'scaling_metrics': self._calculate_scaling_metrics(from_step_results, to_step_results)\n        }\n        \n        self._log_scaling_results(scaling_validation)\n        return scaling_validation\n    \n    def validate_complete_integration(self) -> Dict[str, Any]:\n        \"\"\"Validate complete system integration across all complexity levels.\"\"\"\n        \n        print(\"\ud83c\udf86 Running Complete System Integration Validation\")\n        print(\"=\" * 60)\n        \n        # Define step progression\n        step_progression = [\n            'step1',     # Basic pipeline\n            'step2',     # + Risk container\n            'step3',     # + Classifier container\n            'step4',     # + Multiple strategies\n            'step5',     # + Multiple risk containers\n            'step6',     # + Multiple classifiers\n        ]\n        \n        integration_results = {\n            'success': True,\n            'step_validations': {},\n            'transition_validations': {},\n            'overall_metrics': {},\n            'scaling_analysis': {}\n        }\n        \n        # 1. Validate each step individually\n        for step in step_progression:\n            step_result = self._validate_step_functionality(step)\n            integration_results['step_validations'][step] = step_result\n            \n            if not step_result['success']:\n                integration_results['success'] = False\n                print(f\"\u274c Step {step} validation failed\")\n                break\n            else:\n                print(f\"\u2705 Step {step} validated successfully\")\n        \n        # 2. Validate step transitions\n        if integration_results['success']:\n            for i in range(len(step_progression) - 1):\n                from_step = step_progression[i]\n                to_step = step_progression[i + 1]\n                \n                transition_result = self.validate_step_transition(from_step, to_step)\n                integration_results['transition_validations'][f\"{from_step}_to_{to_step}\"] = transition_result\n                \n                if not transition_result['success']:\n                    integration_results['success'] = False\n                    print(f\"\u274c Transition {from_step} \u2192 {to_step} failed\")\n                    break\n                else:\n                    print(f\"\u2705 Transition {from_step} \u2192 {to_step} validated\")\n        \n        # 3. Calculate overall scaling metrics\n        if integration_results['success']:\n            integration_results['overall_metrics'] = self._calculate_integration_metrics(\n                integration_results['step_validations']\n            )\n            integration_results['scaling_analysis'] = self._analyze_scaling_patterns(\n                integration_results['transition_validations']\n            )\n        \n        self._log_integration_results(integration_results)\n        return integration_results\n    \n    def _validate_step_functionality(self, step_name: str) -> Dict[str, Any]:\n        \"\"\"Validate that a specific step functions correctly.\"\"\"\n        \n        try:\n            # Import the main execution function\n            from src.main import run_backtest\n            \n            # Load step configuration\n            config_path = project_root / \"config\" / f\"{step_name}_validation.yaml\"\n            if not config_path.exists():\n                return {\n                    'success': False,\n                    'error': f\"Configuration file not found: {config_path}\",\n                    'step': step_name\n                }\n            \n            # Run step validation\n            start_time = time.time()\n            \n            results = run_backtest(\n                config_path=str(config_path),\n                mode='validation'\n            )\n            \n            execution_time = time.time() - start_time\n            \n            # Validate results\n            validation_passed = (\n                results.get('status') == 'SUCCESS' and\n                results.get('trade_count', 0) > 0 and\n                results.get('final_portfolio_value', 0) > 0\n            )\n            \n            return {\n                'success': validation_passed,\n                'step': step_name,\n                'execution_time': execution_time,\n                'trade_count': results.get('trade_count', 0),\n                'final_portfolio_value': results.get('final_portfolio_value', 0),\n                'container_count': results.get('container_count', 0),\n                'results': results\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': str(e),\n                'step': step_name\n            }\n    \n    def _validate_coordinator_scaling(self, from_step: str, to_step: str) -> Dict[str, Any]:\n        \"\"\"Validate that coordinator can handle increased complexity.\"\"\"\n        \n        try:\n            # Test that coordinator state management scales\n            from src.core.coordinator import Coordinator\n            \n            coordinator = Coordinator()\n            \n            # Load configurations\n            from_config = self._load_step_config(from_step)\n            to_config = self._load_step_config(to_step)\n            \n            # Validate coordinator can handle both configurations\n            from_complexity = self._calculate_config_complexity(from_config)\n            to_complexity = self._calculate_config_complexity(to_config)\n            \n            scaling_factor = to_complexity / from_complexity if from_complexity > 0 else 1\n            \n            # Test coordinator resource management\n            coordinator_scaling_passed = (\n                scaling_factor < 10 and  # Reasonable scaling\n                to_complexity < 1000     # Within manageable limits\n            )\n            \n            return {\n                'success': coordinator_scaling_passed,\n                'from_complexity': from_complexity,\n                'to_complexity': to_complexity,\n                'scaling_factor': scaling_factor,\n                'coordinator_state': 'healthy'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def _validate_isolation_scaling(self, from_step: str, to_step: str) -> Dict[str, Any]:\n        \"\"\"Validate that event isolation scales with complexity.\"\"\"\n        \n        try:\n            # Run isolation tests with increased complexity\n            test_suite = IsolationTestSuite(self.isolation_manager)\n            isolation_results = test_suite.run_all_tests()\n            \n            # Additional scaling-specific isolation tests\n            scaling_isolation_passed = (\n                isolation_results['overall_passed'] and\n                len(self.isolation_manager._active_containers) == 0  # Clean state\n            )\n            \n            return {\n                'success': scaling_isolation_passed,\n                'isolation_test_results': isolation_results,\n                'active_containers': len(self.isolation_manager._active_containers)\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def _validate_performance_scaling(self, from_step: str, to_step: str) -> Dict[str, Any]:\n        \"\"\"Validate that performance scales acceptably with complexity.\"\"\"\n        \n        # Get performance metrics from step validations\n        from_metrics = self.scaling_results.get(from_step, {})\n        to_metrics = self.scaling_results.get(to_step, {})\n        \n        from_time = from_metrics.get('execution_time', 0)\n        to_time = to_metrics.get('execution_time', 0)\n        \n        # Calculate performance scaling\n        time_scaling_factor = to_time / from_time if from_time > 0 else 1\n        \n        # Performance should scale sub-linearly (better than O(n))\n        performance_acceptable = time_scaling_factor < 5  # Max 5x slowdown\n        \n        return {\n            'success': performance_acceptable,\n            'from_execution_time': from_time,\n            'to_execution_time': to_time,\n            'time_scaling_factor': time_scaling_factor,\n            'performance_acceptable': performance_acceptable\n        }\n    \n    def _calculate_scaling_metrics(self, from_results: Dict, to_results: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate metrics showing how well the system scales.\"\"\"\n        \n        return {\n            'complexity_increase': {\n                'container_count': to_results.get('container_count', 0) - from_results.get('container_count', 0),\n                'execution_time_ratio': to_results.get('execution_time', 0) / max(from_results.get('execution_time', 1), 0.001)\n            },\n            'scaling_efficiency': {\n                'trades_per_second': to_results.get('trade_count', 0) / max(to_results.get('execution_time', 1), 0.001),\n                'performance_degradation': (to_results.get('execution_time', 0) - from_results.get('execution_time', 0)) / max(from_results.get('execution_time', 1), 0.001)\n            }\n        }\n    \n    def _calculate_config_complexity(self, config: Dict) -> int:\n        \"\"\"Calculate complexity score for a configuration.\"\"\"\n        complexity = 0\n        complexity += len(config.get('symbols', [])) * 10\n        complexity += len(config.get('strategies', [])) * 20\n        complexity += len(config.get('risk_profiles', [])) * 15\n        complexity += len(config.get('classifiers', [])) * 25\n        return complexity\n    \n    def _load_step_config(self, step_name: str) -> Dict[str, Any]:\n        \"\"\"Load configuration for a step.\"\"\"\n        # Placeholder - would load actual YAML config\n        return {\n            'symbols': ['SPY'],\n            'strategies': ['sma_cross'],\n            'risk_profiles': ['conservative'],\n            'classifiers': ['simple'] if 'step3' in step_name else []\n        }\n    \n    def _calculate_integration_metrics(self, step_validations: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate overall integration metrics.\"\"\"\n        \n        total_steps = len(step_validations)\n        successful_steps = sum(1 for result in step_validations.values() if result['success'])\n        \n        return {\n            'total_steps_tested': total_steps,\n            'successful_steps': successful_steps,\n            'success_rate': successful_steps / total_steps if total_steps > 0 else 0,\n            'overall_integration_health': 'excellent' if successful_steps == total_steps else 'needs_attention'\n        }\n    \n    def _analyze_scaling_patterns(self, transition_validations: Dict) -> Dict[str, Any]:\n        \"\"\"Analyze scaling patterns across transitions.\"\"\"\n        \n        scaling_factors = []\n        for transition_result in transition_validations.values():\n            if transition_result['success'] and 'scaling_metrics' in transition_result:\n                complexity_ratio = transition_result['scaling_metrics']['complexity_increase']['execution_time_ratio']\n                scaling_factors.append(complexity_ratio)\n        \n        avg_scaling_factor = sum(scaling_factors) / len(scaling_factors) if scaling_factors else 1\n        \n        return {\n            'average_scaling_factor': avg_scaling_factor,\n            'scaling_trend': 'linear' if avg_scaling_factor < 2 else 'super_linear',\n            'scaling_health': 'good' if avg_scaling_factor < 3 else 'concerning'\n        }\n    \n    def _log_scaling_results(self, results: Dict[str, Any]):\n        \"\"\"Log scaling validation results.\"\"\"\n        \n        success = results['success']\n        from_step = results['from_step']\n        to_step = results['to_step']\n        \n        self.logger.log_validation_result(\n            f\"scaling_{from_step}_to_{to_step}\",\n            success,\n            f\"Scaling validation from {from_step} to {to_step}: {'PASSED' if success else 'FAILED'}\"\n        )\n        \n        if success:\n            print(f\"\u2705 Scaling validation {from_step} \u2192 {to_step}: PASSED\")\n        else:\n            print(f\"\u274c Scaling validation {from_step} \u2192 {to_step}: FAILED\")\n            if 'error' in results:\n                print(f\"   Error: {results['error']}\")\n    \n    def _log_integration_results(self, results: Dict[str, Any]):\n        \"\"\"Log complete integration results.\"\"\"\n        \n        success = results['success']\n        \n        self.logger.log_validation_result(\n            \"complete_system_integration\",\n            success,\n            f\"Complete system integration: {'PASSED' if success else 'FAILED'}\"\n        )\n        \n        print(f\"\\n\ud83d\udcca Integration Summary:\")\n        print(f\"  Overall Success: {'\u2705 PASSED' if success else '\u274c FAILED'}\")\n        print(f\"  Steps Tested: {results['overall_metrics']['total_steps_tested']}\")\n        print(f\"  Success Rate: {results['overall_metrics']['success_rate']:.1%}\")\n        print(f\"  Integration Health: {results['overall_metrics']['overall_integration_health']}\")\n        \n        if 'scaling_analysis' in results:\n            print(f\"  Average Scaling Factor: {results['scaling_analysis']['average_scaling_factor']:.2f}x\")\n            print(f\"  Scaling Health: {results['scaling_analysis']['scaling_health']}\")\n\n\ndef main():\n    \"\"\"Main scaling validation function.\"\"\"\n    \n    parser = argparse.ArgumentParser(\n        description=\"Validate system scaling readiness\"\n    )\n    parser.add_argument(\n        \"--from\",\n        dest=\"from_step\",\n        help=\"Starting step (e.g., step1, step2)\"\n    )\n    parser.add_argument(\n        \"--to\",\n        dest=\"to_step\", \n        help=\"Target step (e.g., step2, step3)\"\n    )\n    parser.add_argument(\n        \"--complete-integration\",\n        action=\"store_true\",\n        help=\"Run complete system integration validation\"\n    )\n    parser.add_argument(\n        \"--verbose\", \"-v\",\n        action=\"store_true\",\n        help=\"Enable verbose logging\"\n    )\n    \n    args = parser.parse_args()\n    \n    # Configure logging\n    logging.basicConfig(\n        level=logging.DEBUG if args.verbose else logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    validator = SystemScalingValidator()\n    \n    if args.complete_integration:\n        results = validator.validate_complete_integration()\n    elif args.from_step and args.to_step:\n        results = validator.validate_step_transition(args.from_step, args.to_step)\n    else:\n        print(\"Error: Must specify either --complete-integration or both --from and --to\")\n        sys.exit(1)\n    \n    # Exit with appropriate code\n    sys.exit(0 if results['success'] else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n