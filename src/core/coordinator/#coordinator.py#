g"""
Clean Coordinator implementation using WorkflowExecutor.

This coordinator is much simpler - it just:
1. Takes user config
2. Passes to WorkflowExecutor
3. Returns results

All complexity is properly delegated to workflows and sequences.
"""

import uuid
import logging
from typing import Dict, Any, Optional
from datetime import datetime

from .workflow import WorkflowExecutor
from .topology import TopologyBuilder

logger = logging.getLogger(__name__)


class Coordinator:
    """
    Clean coordinator that delegates to WorkflowExecutor.
    
    This is the main entry point for the system. It:
    1. Accepts user configuration
    2. Manages workflow execution via WorkflowExecutor
    3. Handles event tracing setup (optional)
    4. Returns results to user
    """
    
    def __init__(self, shared_services: Optional[Dict[str, Any]] = None):
        """
        Initialize coordinator.
        
        Args:
            shared_services: Optional shared services like event tracer
        """
        self.coordinator_id = str(uuid.uuid4())
        self.shared_services = shared_services or {}
        
        # Create workflow executor with topology builder
        self.topology_builder = TopologyBuilder()
        self.workflow_executor = WorkflowExecutor(self.topology_builder)
        
        # Optional event tracing
        self.event_tracer = None
        self._setup_event_tracing()
        
        logger.info(f"Coordinator {self.coordinator_id} initialized")
    
    def _setup_event_tracing(self):
        """Setup event tracing if enabled."""
        if self.shared_services.get('enable_event_tracing', False):
            try:
                from ..events.tracing import EventTracer
                self.event_tracer = EventTracer(
                    enabled=True,
                    trace_dir=self.shared_services.get('trace_dir', './traces')
                )
                logger.info("Event tracing initialized")
            except ImportError:
                logger.warning("Event tracing not available")
    
    def run_workflow(
        self,
        config: Dict[str, Any],
        workflow_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Execute a workflow based on configuration.
        
        This is the main entry point for users.
        
        Args:
            config: User configuration including:
                - workflow: Name of workflow to run (default: simple_backtest)
                - data: Data configuration
                - strategies: Strategy configurations
                - Any workflow-specific parameters
            workflow_id: Optional workflow ID for tracking
            
        Returns:
            Dict containing:
                - workflow_id: Unique workflow execution ID
                - success: Whether workflow completed successfully
                - results: Workflow execution results
                - metadata: Execution metadata
        """
        workflow_id = workflow_id or str(uuid.uuid4())
        start_time = datetime.now()
        
        # Apply trace level presets if specified
        config = self._apply_trace_level_config(config)
        
        # Get workflow name
        workflow_name = config.get('workflow', 'simple_backtest')
        
        logger.info(f"Starting workflow: {workflow_name} (ID: {workflow_id})")
        
        try:
            # Execute workflow
            result = self.workflow_executor.execute(workflow_name, config)
            
            # Add event trace if available
            if self.event_tracer:
                trace_summary = self.event_tracer.get_summary()
                result['trace_summary'] = trace_summary
                logger.info(f"Event trace: {trace_summary.get('total_events', 0)} events")
            
            # Add coordinator metadata
            result['workflow_id'] = workflow_id
            result['coordinator_id'] = self.coordinator_id
            result['start_time'] = start_time.isoformat()
            result['end_time'] = datetime.now().isoformat()
            
            return result
            
        except Exception as e:
            logger.error(f"Workflow {workflow_id} failed: {e}")
            return {
                'workflow_id': workflow_id,
                'success': False,
                'error': str(e),
                'workflow_name': workflow_name,
                'start_time': start_time.isoformat(),
                'end_time': datetime.now().isoformat()
            }
    
    def _apply_trace_level_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Apply trace level presets if specified."""
        try:
            from ..events.tracing import (
                get_trace_level_from_config,
                apply_trace_level
            )
            
            trace_level = get_trace_level_from_config(config)
            if trace_level:
                config = apply_trace_level(config, trace_level)
                logger.info(f"Applied trace level preset: {trace_level}")
                
        except ImportError:
            logger.debug("Trace level presets not available")
            
        return config
    
    # Backward compatibility methods
    
    def execute_workflow(
        self,
        config: Dict[str, Any],
        workflow_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Backward compatibility alias for run_workflow."""
        return self.run_workflow(config, workflow_id)