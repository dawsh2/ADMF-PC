"""
Refactored TopologyBuilder Implementation

ONLY builds topologies - no workflow logic, no execution!
Follows single responsibility principle.
Uses existing event tracing infrastructure.
"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
import hashlib
import json

logger = logging.getLogger(__name__)


class TopologyBuilder:
    """
    Builds topologies based on mode and configuration.
    
    That's it. No workflow logic, no execution, no phase management.
    Just a factory for creating topologies.
    
    The topologies it creates include:
    - Containers (already wired with event flow)
    - Adapters (for cross-container communication)
    - Event tracer (if enabled)
    """
    
    def __init__(self):
        """Initialize topology builder."""
        # Map modes to topology creation functions
        self.topology_creators = {
            'backtest': self._create_backtest_topology,
            'signal_generation': self._create_signal_generation_topology,
            'signal_replay': self._create_signal_replay_topology,
            'analysis': self._create_analysis_topology,
            'optimization': self._create_optimization_topology
        }
        
        logger.info("TopologyBuilder initialized")
    
    def build_topology(self, mode: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Build a topology for the given mode and configuration.
        
        This is the ONLY public method.
        
        Args:
            mode: The topology mode (backtest, signal_generation, etc.)
            config: Configuration for the topology (includes event_tracer if needed)
            
        Returns:
            Dict containing the topology structure:
            - containers: Dict of container instances (already wired!)
            - adapters: List of configured adapters
            - event_tracer: Event tracer instance (if enabled)
            - metadata: Additional topology metadata
        """
        logger.info(f"Building {mode} topology")
        
        # Get the appropriate topology creator
        creator = self.topology_creators.get(mode)
        if not creator:
            raise ValueError(f"Unknown topology mode: {mode}")
        
        # Extract event tracer from config if provided
        event_tracer = config.pop('event_tracer', None)
        
        # Create the topology
        topology = creator(config, event_tracer)
        
        # Add metadata
        topology['metadata'] = {
            'mode': mode,
            'created_at': str(datetime.now()),
            'config_hash': self._hash_config(config),
            'tracing_enabled': event_tracer is not None
        }
        
        logger.info(f"Built {mode} topology with {len(topology.get('containers', {}))} containers")
        
        return topology
    
    def register_topology_creator(self, mode: str, creator_func):
        """Register a custom topology creator function."""
        self.topology_creators[mode] = creator_func
        logger.info(f"Registered topology creator for mode: {mode}")
    
    def _create_backtest_topology(self, config: Dict[str, Any], event_tracer: Optional[Any] = None) -> Dict[str, Any]:
        """Create a backtest topology using existing topology modules."""
        # Import the topology module
        from .topologies import create_backtest_topology
        
        # Check if tracing should be enabled
        tracing_enabled = event_tracer is not None or config.get('tracing', {}).get('enabled', True)
        
        # Let the topology module handle all the details
        # It creates containers, wires them up, sets up adapters
        topology = create_backtest_topology(config, tracing_enabled)
        
        # If we have an explicit event tracer, use it
        if event_tracer:
            topology['event_tracer'] = event_tracer
        
        return topology
    
    def _create_signal_generation_topology(self, config: Dict[str, Any], event_tracer: Optional[Any] = None) -> Dict[str, Any]:
        """Create a signal generation topology."""
        from .topologies import create_signal_generation_topology
        
        tracing_enabled = event_tracer is not None or config.get('tracing', {}).get('enabled', True)
        
        topology = create_signal_generation_topology(config, tracing_enabled)
        
        if event_tracer:
            topology['event_tracer'] = event_tracer
        
        return topology
    
    def _create_signal_replay_topology(self, config: Dict[str, Any], event_tracer: Optional[Any] = None) -> Dict[str, Any]:
        """Create a signal replay topology."""
        from .topologies import create_signal_replay_topology
        
        tracing_enabled = event_tracer is not None or config.get('tracing', {}).get('enabled', True)
        
        topology = create_signal_replay_topology(config, tracing_enabled)
        
        if event_tracer:
            topology['event_tracer'] = event_tracer
        
        return topology
    
    def _create_analysis_topology(self, config: Dict[str, Any], event_tracer: Optional[Any] = None) -> Dict[str, Any]:
        """Create an analysis topology."""
        # For now, return a minimal topology
        # In real implementation, this would import from topologies module
        logger.warning("Analysis topology not yet implemented, returning mock")
        
        return {
            'containers': {
                'analyzer': self._create_mock_container('analyzer', 'analysis', config)
            },
            'adapters': [],
            'parameter_combinations': [],
            'event_tracer': event_tracer
        }
    
    def _create_optimization_topology(self, config: Dict[str, Any], event_tracer: Optional[Any] = None) -> Dict[str, Any]:
        """Create an optimization topology."""
        # Optimization is essentially multiple backtests with different parameters
        # Reuse backtest topology with parameter expansion
        from .topologies import create_backtest_topology
        
        # Extract optimization parameters
        param_grid = config.get('parameter_grid', {})
        
        # For each parameter combination, we'll create portfolio containers
        # The topology module handles this
        config['optimization_mode'] = True
        config['parameter_grid'] = param_grid
        
        tracing_enabled = event_tracer is not None or config.get('tracing', {}).get('enabled', True)
        
        topology = create_backtest_topology(config, tracing_enabled)
        
        if event_tracer:
            topology['event_tracer'] = event_tracer
        
        # Add optimization metadata
        topology['metadata'] = topology.get('metadata', {})
        topology['metadata']['optimization'] = {
            'parameter_combinations': len(topology.get('parameter_combinations', [])),
            'parameter_grid': param_grid
        }
        
        return topology
    
    def _create_mock_container(self, name: str, role: str, config: Dict[str, Any]):
        """Create a mock container for unimplemented topologies."""
        # Mock implementation
        # Real implementation would use container factory
        from collections import namedtuple
        
        MockContainer = namedtuple('Container', ['name', 'role', 'config', 'container_id'])
        
        return MockContainer(
            name=name,
            role=role,
            config=config,
            container_id=f"{role}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )
    
    def _hash_config(self, config: Dict[str, Any]) -> str:
        """Generate a hash of the configuration for tracking."""
        # Remove non-serializable items before hashing
        config_copy = config.copy()
        config_copy.pop('event_tracer', None)  # Remove event tracer reference
        
        # Sort keys for consistent hashing
        config_str = json.dumps(config_copy, sort_keys=True, default=str)
        return hashlib.md5(config_str.encode()).hexdigest()[:8]
    
    def get_supported_modes(self) -> List[str]:
        """Get list of supported topology modes."""
        return list(self.topology_creators.keys())
