# ADMF-Trader: Universal Scoped Container Architecture with Protocol + Composition

## Table of Contents

1. [Architectural Overview](#1-architectural-overview)
2. [Universal Container Pattern](#2-universal-container-pattern)
3. [Container Lifecycle Management](#3-container-lifecycle-management)
4. [Use Case Implementations](#4-use-case-implementations)
5. [Performance & Resource Management](#5-performance--resource-management)
6. [Integration Patterns](#6-integration-patterns)
7. [Best Practices & Guidelines](#7-best-practices--guidelines)

---

## 1. Architectural Overview

The Universal Scoped Container Architecture provides a consistent isolation mechanism across all execution contexts in ADMF-Trader. By combining Protocol + Composition with scoped containers, we achieve complete flexibility and isolation without inheritance overhead.

### 1.1 Core Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                     ADMF-Trader System                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Shared Read-Only Layer                       │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │  │
│  │  │ Market Data │ │Configuration│ │ Historical Data │   │  │
│  │  │    Feed     │ │   Service   │ │     Store       │   │  │
│  │  └─────────────┘ └─────────────┘ └─────────────────┘   │  │
│  └─────────────────────────────────────────────────────────┘  │
│                              │                                  │
│  ┌───────────────────────────┴─────────────────────────────┐  │
│  │              Container Orchestration Layer               │  │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │  │
│  │  │ Optimization│ │   Backtest  │ │  Live Trading   │   │  │
│  │  │Orchestrator │ │Orchestrator │ │  Orchestrator   │   │  │
│  │  └─────────────┘ └─────────────┘ └─────────────────┘   │  │
│  └─────────────────────────────────────────────────────────┘  │
│                              │                                  │
│  ┌───────────────────────────┴─────────────────────────────┐  │
│  │                  Scoped Container Layer                  │  │
│  │                                                          │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │  │
│  │  │  Container 1  │  │  Container 2  │  │  Container N  │ │  │
│  │  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │ │  │
│  │  │ │ Strategy │ │  │ │ Strategy │ │  │ │ Strategy │ │ │  │
│  │  │ ├──────────┤ │  │ ├──────────┤ │  │ ├──────────┤ │ │  │
│  │  │ │   Risk   │ │  │ │   Risk   │ │  │ │   Risk   │ │ │  │
│  │  │ ├──────────┤ │  │ ├──────────┤ │  │ ├──────────┤ │ │  │
│  │  │ │Portfolio │ │  │ │Portfolio │ │  │ │Portfolio │ │ │  │
│  │  │ ├──────────┤ │  │ ├──────────┤ │  │ ├──────────┤ │ │  │
│  │  │ │  Broker  │ │  │ │  Broker  │ │  │ │  Broker  │ │ │  │
│  │  │ ├──────────┤ │  │ ├──────────┤ │  │ ├──────────┤ │ │  │
│  │  │ │Event Bus │ │  │ │Event Bus │ │  │ │Event Bus │ │ │  │
│  │  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │ │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘ │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 Key Principles

1. **Universal Isolation**: Every execution context uses the same container pattern
2. **Protocol-Based Components**: Components implement protocols, not inherit from base classes
3. **Shared Nothing Architecture**: Containers share only read-only data
4. **Lifecycle Independence**: Each container manages its own component lifecycles
5. **Resource Efficiency**: Shared read-only layer minimizes memory usage

---

## 2. Universal Container Pattern

### 2.1 Container Protocol Definition

```python
from typing import Protocol, Any, Dict, Optional, List
from abc import abstractmethod

@runtime_checkable
class ScopedContainer(Protocol):
    """Protocol for scoped containers"""
    
    @abstractmethod
    def register_shared_service(self, name: str, service: Any) -> None:
        """Register a shared read-only service"""
        ...
    
    @abstractmethod
    def create_component(self, spec: Dict[str, Any]) -> Any:
        """Create and register a component within this scope"""
        ...
    
    @abstractmethod
    def resolve(self, name: str) -> Any:
        """Resolve a component or service"""
        ...
    
    @abstractmethod
    def initialize_scope(self) -> None:
        """Initialize all components in dependency order"""
        ...
    
    @abstractmethod
    def teardown_scope(self) -> None:
        """Teardown all components in reverse order"""
        ...

class UniversalScopedContainer:
    """Universal implementation of scoped container"""
    
    def __init__(self, container_id: str, shared_services: Dict[str, Any] = None):
        self.container_id = container_id
        self.shared_services = shared_services or {}
        self.local_components: Dict[str, Any] = {}
        self.component_factory = ComponentFactory()
        self.dependency_graph = DependencyGraph()
        self._lock = threading.RLock()
        
        # Container-specific services
        self.event_bus = EventBus()  # Each container gets its own
        self.logger = StructuredLogger(f"container.{container_id}")
        
    def register_shared_service(self, name: str, service: Any) -> None:
        """Register a shared read-only service"""
        with self._lock:
            self.shared_services[name] = service
    
    def create_component(self, spec: Dict[str, Any]) -> Any:
        """Create component with automatic protocol detection"""
        component = self.component_factory.create_component(spec)
        component_name = spec.get('name', component.__class__.__name__)
        
        with self._lock:
            self.local_components[component_name] = component
            
            # Track dependencies
            dependencies = spec.get('dependencies', [])
            self.dependency_graph.add_component(component_name, spec)
            for dep in dependencies:
                self.dependency_graph.add_dependency(component_name, dep)
        
        return component
    
    def resolve(self, name: str) -> Any:
        """Resolve from local components first, then shared services"""
        with self._lock:
            # Check local components first
            if name in self.local_components:
                return self.local_components[name]
            
            # Check container services
            if name == "event_bus":
                return self.event_bus
            if name == "logger":
                return self.logger
            
            # Fall back to shared services
            if name in self.shared_services:
                return self.shared_services[name]
            
            raise ValueError(f"Component '{name}' not found in container {self.container_id}")
    
    def initialize_scope(self) -> None:
        """Initialize all components respecting dependencies"""
        init_order = self.dependency_graph.get_initialization_order()
        
        context = SystemContext(
            config=self.resolve("config") if "config" in self.shared_services else Config(),
            event_bus=self.event_bus,
            container=self,
            logger=self.logger,
            run_mode=self._determine_run_mode()
        )
        
        for component_name in init_order:
            component = self.local_components[component_name]
            
            # Initialize if component supports it (duck typing)
            if hasattr(component, 'initialize') and callable(getattr(component, 'initialize')):
                component.initialize(context)
            
            # Set up event subscriptions if supported
            if hasattr(component, 'initialize_event_subscriptions'):
                component.initialize_event_subscriptions()
    
    def teardown_scope(self) -> None:
        """Teardown all components in reverse order"""
        teardown_order = reversed(self.dependency_graph.get_initialization_order())
        
        for component_name in teardown_order:
            component = self.local_components.get(component_name)
            if component and hasattr(component, 'teardown'):
                try:
                    component.teardown()
                except Exception as e:
                    self.logger.error(f"Error tearing down {component_name}: {e}")
        
        # Clear local components
        self.local_components.clear()
        self.dependency_graph = DependencyGraph()
```

### 2.2 Container Factory

```python
class ContainerFactory:
    """Factory for creating specialized containers"""
    
    def __init__(self, shared_services_provider: 'SharedServicesProvider'):
        self.shared_services_provider = shared_services_provider
        self.container_count = 0
        self._lock = threading.Lock()
    
    def create_optimization_container(self, parameters: Dict[str, Any]) -> UniversalScopedContainer:
        """Create container for optimization trial"""
        container_id = self._generate_container_id("opt")
        shared_services = self.shared_services_provider.get_optimization_services()
        
        container = UniversalScopedContainer(container_id, shared_services)
        
        # Create components with specific parameters
        container.create_component({
            'name': 'strategy',
            'class': parameters['strategy_class'],
            'params': parameters['strategy_params'],
            'capabilities': ['lifecycle', 'events', 'optimization']
        })
        
        container.create_component({
            'name': 'portfolio',
            'class': 'Portfolio',
            'params': {'initial_cash': 100000},
            'capabilities': ['lifecycle', 'events', 'reset']
        })
        
        # ... create other components ...
        
        return container
    
    def create_live_trading_container(self, strategy_spec: Dict[str, Any]) -> UniversalScopedContainer:
        """Create container for live trading strategy"""
        container_id = self._generate_container_id("live")
        shared_services = self.shared_services_provider.get_live_trading_services()
        
        container = UniversalScopedContainer(container_id, shared_services)
        
        # Create components for live trading
        container.create_component({
            'name': 'strategy',
            'class': strategy_spec['class'],
            'params': strategy_spec['params'],
            'capabilities': ['lifecycle', 'events', 'monitoring']
        })
        
        # Virtual portfolio for tracking
        container.create_component({
            'name': 'portfolio',
            'class': 'VirtualPortfolio',
            'params': {
                'strategy_id': container_id,
                'initial_capital': strategy_spec.get('allocated_capital', 100000)
            }
        })
        
        return container
    
    def create_test_container(self, test_spec: Dict[str, Any]) -> UniversalScopedContainer:
        """Create container for testing/development"""
        container_id = self._generate_container_id("test")
        shared_services = self.shared_services_provider.get_test_services()
        
        container = UniversalScopedContainer(container_id, shared_services)
        
        # Flexible component creation for testing
        for component_spec in test_spec.get('components', []):
            container.create_component(component_spec)
        
        return container
    
    def _generate_container_id(self, prefix: str) -> str:
        """Generate unique container ID"""
        with self._lock:
            self.container_count += 1
            return f"{prefix}_{self.container_count}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
```

### 2.3 Shared Services Provider

```python
class SharedServicesProvider:
    """Manages shared read-only services across containers"""
    
    def __init__(self):
        self._services: Dict[str, Any] = {}
        self._initialize_core_services()
    
    def _initialize_core_services(self) -> None:
        """Initialize core shared services"""
        # Configuration service
        self._services['config'] = Config.load("config/system.yaml")
        
        # Market data service (read-only interface)
        self._services['market_data'] = MarketDataService()
        
        # Historical data store
        self._services['historical_data'] = HistoricalDataStore()
        
        # System monitor (read-only metrics)
        self._services['system_monitor'] = SystemMonitor()
    
    def get_optimization_services(self) -> Dict[str, Any]:
        """Get services for optimization containers"""
        return {
            'config': self._services['config'],
            'historical_data': self._services['historical_data'],
            'market_data': ReadOnlyDataView(self._services['market_data'])
        }
    
    def get_live_trading_services(self) -> Dict[str, Any]:
        """Get services for live trading containers"""
        return {
            'config': self._services['config'],
            'market_data': self._services['market_data'],
            'order_router': self._services.get('order_router'),  # Thread-safe router
            'system_monitor': self._services['system_monitor']
        }
    
    def get_test_services(self) -> Dict[str, Any]:
        """Get services for test containers"""
        return {
            'config': self._services['config'],
            'historical_data': self._services['historical_data']
        }
```

---

## 3. Container Lifecycle Management

### 3.1 Lifecycle Flow Diagram

```
┌─────────────────┐
│   Container     │
│   Creation      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Register Shared │
│   Services      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│Create Components│
│  (Lazy Init)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Build Dep.     │
│    Graph        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   Initialize    │
│   Components    │
│ (Dependency     │
│    Order)       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│    Active       │
│  (Processing)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│    Teardown     │
│  (Reverse       │
│   Order)        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   Container     │
│   Destroyed     │
└─────────────────┘
```

### 3.2 Lifecycle Manager

```python
class ContainerLifecycleManager:
    """Manages lifecycle of multiple containers"""
    
    def __init__(self):
        self.active_containers: Dict[str, UniversalScopedContainer] = {}
        self.container_factory = ContainerFactory(SharedServicesProvider())
        self._lock = threading.RLock()
    
    def create_and_start_container(self, container_type: str, 
                                  spec: Dict[str, Any]) -> str:
        """Create, initialize, and start a container"""
        # Create appropriate container
        if container_type == "optimization":
            container = self.container_factory.create_optimization_container(spec)
        elif container_type == "live_trading":
            container = self.container_factory.create_live_trading_container(spec)
        elif container_type == "test":
            container = self.container_factory.create_test_container(spec)
        else:
            raise ValueError(f"Unknown container type: {container_type}")
        
        # Initialize container
        container.initialize_scope()
        
        # Start components
        self._start_container_components(container)
        
        # Track active container
        with self._lock:
            self.active_containers[container.container_id] = container
        
        return container.container_id
    
    def stop_and_destroy_container(self, container_id: str) -> None:
        """Stop and destroy a container"""
        with self._lock:
            if container_id not in self.active_containers:
                return
            
            container = self.active_containers[container_id]
        
        # Stop components
        self._stop_container_components(container)
        
        # Teardown
        container.teardown_scope()
        
        # Remove from tracking
        with self._lock:
            del self.active_containers[container_id]
    
    def _start_container_components(self, container: UniversalScopedContainer) -> None:
        """Start all components that support starting"""
        for name, component in container.local_components.items():
            if hasattr(component, 'start') and callable(getattr(component, 'start')):
                try:
                    component.start()
                except Exception as e:
                    container.logger.error(f"Error starting {name}: {e}")
    
    def _stop_container_components(self, container: UniversalScopedContainer) -> None:
        """Stop all components in reverse order"""
        for name in reversed(list(container.local_components.keys())):
            component = container.local_components[name]
            if hasattr(component, 'stop') and callable(getattr(component, 'stop')):
                try:
                    component.stop()
                except Exception as e:
                    container.logger.error(f"Error stopping {name}: {e}")
```

---

## 4. Use Case Implementations

### 4.1 Parallel Optimization

```python
class ParallelOptimizationOrchestrator:
    """Orchestrates parallel optimization using containers"""
    
    def __init__(self, optimization_config: Dict[str, Any]):
        self.config = optimization_config
        self.lifecycle_manager = ContainerLifecycleManager()
        self.results_collector = OptimizationResultsCollector()
        self.shared_data_handler = self._create_shared_data_handler()
    
    def run_optimization(self, parameter_space: Dict[str, Any]) -> Dict[str, Any]:
        """Run parallel optimization with scoped containers"""
        # Generate parameter combinations
        param_combinations = self._generate_parameter_combinations(parameter_space)
        
        # Determine batch size based on resources
        batch_size = self._calculate_optimal_batch_size(len(param_combinations))
        
        # Process in batches
        all_results = []
        
        for batch_start in range(0, len(param_combinations), batch_size):
            batch_end = min(batch_start + batch_size, len(param_combinations))
            batch_params = param_combinations[batch_start:batch_end]
            
            # Run batch in parallel
            batch_results = self._run_optimization_batch(batch_params)
            all_results.extend(batch_results)
            
            # Memory cleanup between batches
            gc.collect()
        
        # Find best parameters
        return self._analyze_optimization_results(all_results)
    
    def _run_optimization_batch(self, batch_params: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Run a batch of optimizations in parallel containers"""
        with ThreadPoolExecutor(max_workers=len(batch_params)) as executor:
            futures = []
            
            for params in batch_params:
                future = executor.submit(self._run_single_optimization, params)
                futures.append(future)
            
            # Collect results
            results = []
            for future in as_completed(futures):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    self.logger.error(f"Optimization failed: {e}")
                    results.append({'error': str(e), 'params': params})
            
            return results
    
    def _run_single_optimization(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Run single optimization in isolated container"""
        # Create container
        container_id = self.lifecycle_manager.create_and_start_container(
            "optimization", 
            parameters
        )
        
        try:
            container = self.lifecycle_manager.active_containers[container_id]
            
            # Get components
            strategy = container.resolve("strategy")
            portfolio = container.resolve("portfolio")
            data_handler = container.resolve("data_handler")
            
            # Run backtest
            results = self._execute_backtest(container)
            
            # Add container metrics
            results['container_id'] = container_id
            results['parameters'] = parameters
            results['memory_usage'] = self._get_container_memory_usage(container)
            
            return results
            
        finally:
            # Always cleanup container
            self.lifecycle_manager.stop_and_destroy_container(container_id)
```

### 4.2 Out-of-Sample Testing

```python
class OutOfSampleTestRunner:
    """Runs OOS tests using optimization insights"""
    
    def __init__(self, optimization_results: Dict[str, Any]):
        self.optimization_results = optimization_results
        self.lifecycle_manager = ContainerLifecycleManager()
        self.strategy_generator = OOSStrategyGenerator(optimization_results)
    
    def run_oos_tests(self, test_data: Any) -> Dict[str, Any]:
        """Run out-of-sample tests with generated strategies"""
        # Generate OOS strategies based on optimization data
        oos_strategies = self.strategy_generator.generate_strategies()
        
        # Run each strategy in isolated container
        test_results = {}
        
        with ProcessPoolExecutor() as executor:
            futures = {}
            
            for strategy_name, strategy_spec in oos_strategies.items():
                future = executor.submit(
                    self._run_oos_strategy,
                    strategy_name,
                    strategy_spec,
                    test_data
                )
                futures[future] = strategy_name
            
            # Collect results
            for future in as_completed(futures):
                strategy_name = futures[future]
                try:
                    result = future.result()
                    test_results[strategy_name] = result
                except Exception as e:
                    test_results[strategy_name] = {'error': str(e)}
        
        return self._analyze_oos_results(test_results)
    
    def _run_oos_strategy(self, strategy_name: str, 
                         strategy_spec: Dict[str, Any],
                         test_data: Any) -> Dict[str, Any]:
        """Run single OOS strategy in isolated container"""
        # Create test container
        test_spec = {
            'components': [
                strategy_spec,
                {'name': 'portfolio', 'class': 'Portfolio', 'params': {'initial_cash': 100000}},
                {'name': 'risk_manager', 'class': 'RiskManager'},
                {'name': 'broker', 'class': 'SimulatedBroker'}
            ]
        }
        
        container_id = self.lifecycle_manager.create_and_start_container("test", test_spec)
        
        try:
            # Run test
            return self._execute_test(container_id, test_data)
        finally:
            self.lifecycle_manager.stop_and_destroy_container(container_id)

class OOSStrategyGenerator:
    """Generates out-of-sample test strategies"""
    
    def __init__(self, optimization_results: Dict[str, Any]):
        self.optimization_results = optimization_results
    
    def generate_strategies(self) -> Dict[str, Dict[str, Any]]:
        """Generate diverse OOS strategies"""
        strategies = {}
        
        # 1. Best parameters strategy
        strategies['best_params'] = {
            'name': 'best_params_strategy',
            'class': self.optimization_results['strategy_class'],
            'params': self.optimization_results['best_parameters']
        }
        
        # 2. Robust parameters (good across multiple regimes)
        strategies['robust_params'] = self._generate_robust_strategy()
        
        # 3. Ensemble of top N
        strategies['ensemble_top5'] = self._generate_ensemble_strategy(top_n=5)
        
        # 4. Contrarian for worst regime
        strategies['contrarian'] = self._generate_contrarian_strategy()
        
        # 5. Adaptive strategy switching between parameter sets
        strategies['adaptive'] = self._generate_adaptive_strategy()
        
        return strategies
```

### 4.3 Live Trading Multi-Strategy

```python
class LiveTradingOrchestrator:
    """Manages multiple live trading strategies in isolation"""
    
    def __init__(self, broker_connection: Any):
        self.broker_connection = broker_connection
        self.lifecycle_manager = ContainerLifecycleManager()
        self.position_aggregator = PositionAggregator()
        self.risk_monitor = SystemRiskMonitor()
        self.strategy_threads: Dict[str, Thread] = {}
    
    def add_live_strategy(self, strategy_id: str, 
                         strategy_spec: Dict[str, Any]) -> None:
        """Add a live trading strategy"""
        # Create live trading container
        container_id = self.lifecycle_manager.create_and_start_container(
            "live_trading",
            strategy_spec
        )
        
        # Map strategy ID to container
        strategy_spec['container_id'] = container_id
        
        # Start strategy thread
        thread = Thread(
            target=self._run_live_strategy,
            args=(strategy_id, container_id),
            name=f"LiveStrategy_{strategy_id}"
        )
        thread.daemon = True
        self.strategy_threads[strategy_id] = thread
        thread.start()
        
        self.logger.info(f"Started live strategy {strategy_id} in container {container_id}")
    
    def _run_live_strategy(self, strategy_id: str, container_id: str) -> None:
        """Run live strategy in its container"""
        try:
            container = self.lifecycle_manager.active_containers[container_id]
            strategy = container.resolve("strategy")
            
            # Strategy main loop
            while self._should_run_strategy(strategy_id):
                try:
                    # Each strategy processes its own events
                    # via its isolated event bus
                    time.sleep(0.001)
                    
                    # Periodic position reporting
                    if self._should_report_positions():
                        self._report_strategy_positions(strategy_id, container)
                    
                except Exception as e:
                    self.logger.error(f"Error in strategy {strategy_id}: {e}")
                    self._handle_strategy_error(strategy_id, e)
                    
        except Exception as e:
            self.logger.critical(f"Fatal error in strategy {strategy_id}: {e}")
        finally:
            self.lifecycle_manager.stop_and_destroy_container(container_id)
    
    def get_system_state(self) -> Dict[str, Any]:
        """Get aggregated system state across all strategies"""
        state = {
            'active_strategies': len(self.strategy_threads),
            'total_positions': {},
            'strategy_states': {},
            'system_metrics': self.risk_monitor.get_metrics()
        }
        
        # Aggregate positions across all containers
        for strategy_id, thread in self.strategy_threads.items():
            if thread.is_alive():
                container_id = self._get_container_id(strategy_id)
                container = self.lifecycle_manager.active_containers.get(container_id)
                
                if container:
                    portfolio = container.resolve("portfolio")
                    positions = portfolio.get_all_positions()
                    
                    # Add to aggregated positions
                    for symbol, position in positions.items():
                        if symbol not in state['total_positions']:
                            state['total_positions'][symbol] = 0
                        state['total_positions'][symbol] += position.quantity
                    
                    # Strategy-specific state
                    state['strategy_states'][strategy_id] = {
                        'positions': positions,
                        'portfolio_value': portfolio.get_portfolio_value(),
                        'container_id': container_id
                    }
        
        return state
```

### 4.4 A/B Testing in Production

```python
class ProductionABTestManager:
    """Manages A/B tests in production using containers"""
    
    def __init__(self, total_capital: float):
        self.total_capital = total_capital
        self.lifecycle_manager = ContainerLifecycleManager()
        self.test_results: Dict[str, Any] = {}
        self.test_start_time = datetime.now()
    
    def setup_ab_test(self, test_config: Dict[str, Any]) -> None:
        """Set up A/B test with control and variants"""
        control_allocation = test_config['control_allocation']  # e.g., 80%
        variant_allocations = test_config['variant_allocations']  # e.g., {'v1': 10%, 'v2': 10%}
        
        # Set up control strategy
        control_capital = self.total_capital * (control_allocation / 100)
        self._setup_test_strategy(
            'control',
            test_config['control_strategy'],
            control_capital
        )
        
        # Set up variant strategies
        for variant_id, allocation in variant_allocations.items():
            variant_capital = self.total_capital * (allocation / 100)
            self._setup_test_strategy(
                variant_id,
                test_config['variants'][variant_id],
                variant_capital
            )
    
    def _setup_test_strategy(self, test_id: str, 
                           strategy_spec: Dict[str, Any],
                           allocated_capital: float) -> None:
        """Set up individual test strategy in container"""
        # Enhance spec with test metadata
        enhanced_spec = strategy_spec.copy()
        enhanced_spec['allocated_capital'] = allocated_capital
        enhanced_spec['test_id'] = test_id
        enhanced_spec['test_start'] = self.test_start_time
        
        # Create container
        container_id = self.lifecycle_manager.create_and_start_container(
            "live_trading",
            enhanced_spec
        )
        
        # Track test
        self.test_results[test_id] = {
            'container_id': container_id,
            'start_time': datetime.now(),
            'allocated_capital': allocated_capital,
            'performance_metrics': []
        }
    
    def get_test_results(self) -> Dict[str, Any]:
        """Get current A/B test results"""
        results = {
            'test_duration': (datetime.now() - self.test_start_time).total_seconds() / 3600,
            'variants': {}
        }
        
        for test_id, test_info in self.test_results.items():
            container = self.lifecycle_manager.active_containers.get(test_info['container_id'])
            
            if container:
                portfolio = container.resolve("portfolio")
                current_value = portfolio.get_portfolio_value()
                
                results['variants'][test_id] = {
                    'current_value': current_value,
                    'return': (current_value - test_info['allocated_capital']) / test_info['allocated_capital'],
                    'sharpe_ratio': self._calculate_sharpe(test_id),
                    'max_drawdown': self._calculate_max_drawdown(test_id),
                    'trade_count': len(portfolio.trades)
                }
        
        # Statistical significance testing
        if len(results['variants']) > 1:
            results['statistical_analysis'] = self._perform_statistical_tests(results['variants'])
        
        return results
```

---

## 5. Performance & Resource Management

### 5.1 Memory Management Architecture

```
┌─────────────────────────────────────────────────────────┐
│                  Memory Layout                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │          Shared Read-Only Memory                 │  │
│  │   ┌─────────────┐      ┌──────────────┐        │  │
│  │   │ Market Data │      │ Historical   │        │  │
│  │   │   (mmap)    │      │ Data (mmap)  │        │  │
│  │   └─────────────┘      └──────────────┘        │  │
│  └─────────────────────────────────────────────────┘  │
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │            Per-Container Memory                  │  │
│  │                                                  │  │
│  │  Container 1          Container 2         ...   │  │
│  │  ┌──────────┐        ┌──────────┐              │  │
│  │  │ Strategy │        │ Strategy │              │  │
│  │  │   State  │        │   State  │              │  │
│  │  ├──────────┤        ├──────────┤              │  │
│  │  │Portfolio │        │Portfolio │              │  │
│  │  │  State   │        │  State   │              │  │
│  │  ├──────────┤        ├──────────┤              │  │
│  │  │  Event   │        │  Event   │              │  │
│  │  │  Queue   │        │  Queue   │              │  │
│  │  └──────────┘        └──────────┘              │  │
│  └─────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 5.2 Resource Manager

```python
class ContainerResourceManager:
    """Manages resources across all containers"""
    
    def __init__(self, max_memory_gb: float = 16.0, 
                 max_containers: int = 100):
        self.max_memory_gb = max_memory_gb
        self.max_containers = max_containers
        self.container_metrics: Dict[str, Dict[str, Any]] = {}
        self._lock = threading.RLock()
    
    def can_create_container(self) -> bool:
        """Check if resources available for new container"""
        with self._lock:
            current_containers = len(self.container_metrics)
            current_memory = self._get_total_memory_usage()
            
            # Check limits
            if current_containers >= self.max_containers:
                return False
            
            # Estimate memory for new container (conservative)
            estimated_new_container_memory = 0.1  # 100MB estimate
            
            if current_memory + estimated_new_container_memory > self.max_memory_gb:
                return False
            
            return True
    
    def register_container(self, container_id: str) -> None:
        """Register new container for monitoring"""
        with self._lock:
            self.container_metrics[container_id] = {
                'created_at': datetime.now(),
                'memory_usage': 0,
                'cpu_usage': 0,
                'event_count': 0
            }
    
    def update_container_metrics(self, container_id: str, 
                               metrics: Dict[str, Any]) -> None:
        """Update container resource metrics"""
        with self._lock:
            if container_id in self.container_metrics:
                self.container_metrics[container_id].update(metrics)
    
    def get_optimization_recommendations(self) -> Dict[str, Any]:
        """Get recommendations for resource optimization"""
        with self._lock:
            total_memory = self._get_total_memory_usage()
            container_count = len(self.container_metrics)
            
            recommendations = {
                'optimal_batch_size': self._calculate_optimal_batch_size(),
                'memory_pressure': total_memory / self.max_memory_gb,
                'suggested_actions': []
            }
            
            # High memory pressure
            if recommendations['memory_pressure'] > 0.8:
                recommendations['suggested_actions'].append(
                    "Consider reducing batch size or using disk-based data storage"
                )
            
            # Many idle containers
            idle_containers = self._find_idle_containers()
            if len(idle_containers) > container_count * 0.2:
                recommendations['suggested_actions'].append(
                    f"Consider removing {len(idle_containers)} idle containers"
                )
            
            return recommendations
    
    def _calculate_optimal_batch_size(self) -> int:
        """Calculate optimal batch size based on resources"""
        available_memory = self.max_memory_gb - self._get_total_memory_usage()
        avg_container_memory = 0.1  # 100MB average
        
        # Leave 20% buffer
        usable_memory = available_memory * 0.8
        optimal_batch = int(usable_memory / avg_container_memory)
        
        # Apply reasonable limits
        return max(1, min(optimal_batch, 50))
```

### 5.3 Performance Monitoring

```python
class ContainerPerformanceMonitor:
    """Monitors performance across containers"""
    
    def __init__(self):
        self.metrics_buffer: Dict[str, List[Dict[str, Any]]] = {}
        self.aggregated_metrics: Dict[str, Any] = {}
        self._lock = threading.RLock()
    
    def record_container_metric(self, container_id: str, 
                              metric_name: str, 
                              value: float) -> None:
        """Record performance metric for container"""
        with self._lock:
            if container_id not in self.metrics_buffer:
                self.metrics_buffer[container_id] = []
            
            self.metrics_buffer[container_id].append({
                'timestamp': datetime.now(),
                'metric': metric_name,
                'value': value
            })
            
            # Limit buffer size
            if len(self.metrics_buffer[container_id]) > 1000:
                self.metrics_buffer[container_id].pop(0)
    
    def get_container_performance_summary(self, container_id: str) -> Dict[str, Any]:
        """Get performance summary for specific container"""
        with self._lock:
            if container_id not in self.metrics_buffer:
                return {}
            
            metrics = self.metrics_buffer[container_id]
            
            # Group by metric name
            grouped = {}
            for entry in metrics:
                metric_name = entry['metric']
                if metric_name not in grouped:
                    grouped[metric_name] = []
                grouped[metric_name].append(entry['value'])
            
            # Calculate statistics
            summary = {}
            for metric_name, values in grouped.items():
                if values:
                    summary[metric_name] = {
                        'count': len(values),
                        'mean': np.mean(values),
                        'std': np.std(values),
                        'min': np.min(values),
                        'max': np.max(values),
                        'p50': np.percentile(values, 50),
                        'p95': np.percentile(values, 95)
                    }
            
            return summary
    
    def get_system_performance_dashboard(self) -> Dict[str, Any]:
        """Get system-wide performance dashboard"""
        with self._lock:
            active_containers = len(self.metrics_buffer)
            
            # Aggregate metrics across all containers
            all_metrics = []
            for container_metrics in self.metrics_buffer.values():
                all_metrics.extend(container_metrics)
            
            # Calculate system-wide statistics
            if all_metrics:
                recent_metrics = [m for m in all_metrics 
                                if (datetime.now() - m['timestamp']).seconds < 300]  # Last 5 minutes
                
                return {
                    'active_containers': active_containers,
                    'total_events_processed': len(recent_metrics),
                    'events_per_second': len(recent_metrics) / 300,
                    'container_performance': self._aggregate_container_performance(),
                    'system_health': self._calculate_system_health()
                }
            
            return {'active_containers': 0, 'status': 'no_data'}
```

---

## 6. Integration Patterns

### 6.1 Component Discovery and Registration

```python
class ContainerComponentRegistry:
    """Registry for components that can be used in containers"""
    
    def __init__(self):
        self.component_specs: Dict[str, Dict[str, Any]] = {}
        self.protocol_implementations: Dict[str, List[str]] = {}
        self._scan_for_components()
    
    def _scan_for_components(self) -> None:
        """Scan for available components"""
        # Scan built-in components
        self._register_builtin_components()
        
        # Scan for user components
        self._scan_user_components()
    
    def _register_builtin_components(self) -> None:
        """Register built-in components"""
        # Strategies
        self.register_component('TrendFollowingStrategy', {
            'class': 'strategies.TrendFollowingStrategy',
            'protocols': ['SignalGenerator', 'Optimizable', 'Resettable'],
            'default_params': {'fast_period': 10, 'slow_period': 30},
            'capabilities': ['lifecycle', 'events', 'optimization']
        })
        
        # Risk Management
        self.register_component('RiskManager', {
            'class': 'risk.RiskManager',
            'protocols': ['EventSubscriber', 'Configurable'],
            'default_params': {'max_position_size': 1000},
            'capabilities': ['lifecycle', 'events']
        })
        
        # Portfolio
        self.register_component('Portfolio', {
            'class': 'risk.Portfolio',
            'protocols': ['EventSubscriber', 'Resettable'],
            'default_params': {'initial_cash': 100000},
            'capabilities': ['lifecycle', 'events', 'reset']
        })
    
    def register_component(self, name: str, spec: Dict[str, Any]) -> None:
        """Register a component specification"""
        self.component_specs[name] = spec
        
        # Track protocol implementations
        for protocol in spec.get('protocols', []):
            if protocol not in self.protocol_implementations:
                self.protocol_implementations[protocol] = []
            self.protocol_implementations[protocol].append(name)
    
    def find_components_by_protocol(self, protocol: str) -> List[str]:
        """Find all components implementing a protocol"""
        return self.protocol_implementations.get(protocol, [])
    
    def get_component_spec(self, name: str) -> Dict[str, Any]:
        """Get component specification"""
        return self.component_specs.get(name, {})
```

### 6.2 Inter-Container Communication

```python
class InterContainerMessageBus:
    """Enables controlled communication between containers"""
    
    def __init__(self):
        self.channels: Dict[str, List[Callable]] = {}
        self.container_subscriptions: Dict[str, List[str]] = {}
        self._lock = threading.RLock()
    
    def create_channel(self, channel_name: str, 
                      access_policy: Dict[str, Any]) -> None:
        """Create communication channel with access policy"""
        with self._lock:
            self.channels[channel_name] = {
                'subscribers': [],
                'policy': access_policy,
                'created_at': datetime.now()
            }
    
    def subscribe_container(self, container_id: str, 
                          channel_name: str,
                          handler: Callable) -> bool:
        """Subscribe container to channel if allowed"""
        with self._lock:
            if channel_name not in self.channels:
                return False
            
            # Check access policy
            policy = self.channels[channel_name]['policy']
            if not self._check_access_policy(container_id, policy):
                return False
            
            # Add subscription
            self.channels[channel_name]['subscribers'].append({
                'container_id': container_id,
                'handler': handler
            })
            
            # Track container subscriptions
            if container_id not in self.container_subscriptions:
                self.container_subscriptions[container_id] = []
            self.container_subscriptions[container_id].append(channel_name)
            
            return True
    
    def publish_to_channel(self, channel_name: str, 
                         message: Dict[str, Any],
                         sender_container_id: str) -> None:
        """Publish message to channel"""
        with self._lock:
            if channel_name not in self.channels:
                return
            
            # Add sender info
            message['sender_container'] = sender_container_id
            message['timestamp'] = datetime.now()
            
            # Deliver to subscribers
            for subscription in self.channels[channel_name]['subscribers']:
                if subscription['container_id'] != sender_container_id:  # No self-delivery
                    try:
                        subscription['handler'](message)
                    except Exception as e:
                        print(f"Error delivering message: {e}")
    
    def _check_access_policy(self, container_id: str, 
                           policy: Dict[str, Any]) -> bool:
        """Check if container meets access policy"""
        # Example policy checks
        if 'allowed_types' in policy:
            container_type = self._get_container_type(container_id)
            if container_type not in policy['allowed_types']:
                return False
        
        if 'max_subscribers' in policy:
            current_subs = len(self.channels[channel_name]['subscribers'])
            if current_subs >= policy['max_subscribers']:
                return False
        
        return True
```

---

## 7. Best Practices & Guidelines

### 7.1 Container Design Patterns

#### 7.1.1 Minimal Container Pattern
```python
# For simple, single-purpose operations
def create_minimal_container(strategy_func: Callable) -> UniversalScopedContainer:
    """Create minimal container for simple strategies"""
    container = UniversalScopedContainer("minimal")
    
    # Only essential components
    container.create_component({
        'name': 'strategy',
        'function': strategy_func,
        'capabilities': []  # No framework overhead
    })
    
    container.create_component({
        'name': 'data_handler',
        'class': 'SimpleDataHandler',
        'capabilities': ['reset']  # Only what's needed
    })
    
    return container
```

#### 7.1.2 Full-Featured Container Pattern
```python
# For complex production strategies
def create_production_container(strategy_config: Dict[str, Any]) -> UniversalScopedContainer:
    """Create fully-featured container for production"""
    container = UniversalScopedContainer("production")
    
    # All production capabilities
    components = [
        {
            'name': 'strategy',
            'class': strategy_config['class'],
            'params': strategy_config['params'],
            'capabilities': ['lifecycle', 'events', 'optimization', 
                           'monitoring', 'error_handling']
        },
        {
            'name': 'risk_manager',
            'class': 'EnhancedRiskManager',
            'capabilities': ['lifecycle', 'events', 'monitoring']
        },
        {
            'name': 'portfolio',
            'class': 'ProductionPortfolio',
            'capabilities': ['lifecycle', 'events', 'reset', 'monitoring']
        },
        {
            'name': 'performance_tracker',
            'class': 'PerformanceTracker',
            'capabilities': ['lifecycle', 'monitoring']
        }
    ]
    
    for component_spec in components:
        container.create_component(component_spec)
    
    return container
```

### 7.2 Resource Management Guidelines

1. **Memory Limits**: Set explicit memory limits per container type
2. **Batch Sizing**: Use adaptive batch sizing based on available resources
3. **Cleanup**: Always use try/finally blocks for container cleanup
4. **Monitoring**: Track container metrics for optimization
5. **Pooling**: Consider container pooling for frequently created/destroyed patterns

### 7.3 Testing Patterns

```python
class ContainerTestFramework:
    """Framework for testing containerized components"""
    
    def test_strategy_in_isolation(self, strategy_class: type) -> None:
        """Test strategy in complete isolation"""
        # Create test container
        container = UniversalScopedContainer("test")
        
        # Create strategy with test dependencies
        container.create_component({
            'name': 'strategy',
            'class': strategy_class,
            'params': {'test_mode': True}
        })
        
        # Mock dependencies
        container.register_shared_service('market_data', MockMarketData())
        
        # Initialize and test
        container.initialize_scope()
        
        try:
            strategy = container.resolve('strategy')
            # Run tests...
        finally:
            container.teardown_scope()
    
    def test_container_isolation(self) -> None:
        """Verify containers are truly isolated"""
        container1 = UniversalScopedContainer("test1")
        container2 = UniversalScopedContainer("test2")
        
        # Create same component in both
        for container in [container1, container2]:
            container.create_component({
                'name': 'counter',
                'class': 'SimpleCounter'
            })
        
        # Verify isolation
        counter1 = container1.resolve('counter')
        counter2 = container2.resolve('counter')
        
        counter1.increment()
        assert counter1.value == 1
        assert counter2.value == 0  # Isolated!
```

### 7.4 Production Deployment Checklist

- [ ] Container resource limits configured
- [ ] Monitoring enabled for all containers
- [ ] Error boundaries implemented
- [ ] Graceful shutdown handlers registered
- [ ] Inter-container communication policies defined
- [ ] Performance baselines established
- [ ] Disaster recovery procedures documented
- [ ] Container health checks implemented
- [ ] Audit logging enabled
- [ ] Security policies enforced

---

## Summary

The Universal Scoped Container Architecture with Protocol + Composition provides:

1. **Complete Isolation**: Every execution context is isolated
2. **Maximum Flexibility**: Any component can be used in any container
3. **Resource Efficiency**: Shared read-only, isolated mutable state
4. **Universal Pattern**: Same architecture for all use cases
5. **Production Ready**: Built-in monitoring, error handling, and resource management

This architecture enables ADMF-Trader to scale from simple backtests to complex production deployments while maintaining clean separation of concerns and optimal resource utilization.
